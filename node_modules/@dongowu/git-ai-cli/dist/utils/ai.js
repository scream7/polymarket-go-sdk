import OpenAI from 'openai';
import { runAgentLoop } from './agent.js';
import { runAgentLite } from './agent_lite.js';
import { getFileStats } from './git.js';
import chalk from 'chalk';
function getTimeoutMs() {
    const raw = process.env.GIT_AI_TIMEOUT_MS;
    const parsed = raw ? Number.parseInt(raw, 10) : Number.NaN;
    if (Number.isFinite(parsed) && parsed > 0)
        return parsed;
    return 120_000; // 2 minutes
}
function parseBooleanEnv(value) {
    if (!value)
        return undefined;
    const normalized = value.trim().toLowerCase();
    if (['1', 'true', 'yes', 'y', 'on'].includes(normalized))
        return true;
    if (['0', 'false', 'no', 'n', 'off'].includes(normalized))
        return false;
    return undefined;
}
function getMaxOutputTokens(numChoices) {
    const raw = process.env.GIT_AI_MAX_OUTPUT_TOKENS || process.env.OCO_TOKENS_MAX_OUTPUT;
    const parsed = raw ? Number.parseInt(raw, 10) : Number.NaN;
    const base = Number.isFinite(parsed) && parsed > 0 ? parsed : 500;
    return base * Math.max(numChoices, 1);
}
function getModelCandidates(config) {
    const primary = (config.model || '').trim();
    const fallbacks = Array.isArray(config.fallbackModels) ? config.fallbackModels : [];
    const cleaned = fallbacks.map((m) => String(m).trim()).filter(Boolean);
    const unique = [primary, ...cleaned.filter((m) => m && m !== primary)];
    return unique.filter(Boolean);
}
function redactSecrets(input) {
    if (!input)
        return input;
    // Generic "api key: xxxx" patterns.
    let out = input.replace(/(api[_ -]?key\s*[:=]\s*)([^\s,;]+)/gi, (_m, p1, p2) => {
        const s = String(p2);
        if (s.length <= 8)
            return `${p1}********`;
        return `${p1}${s.slice(0, 2)}****${s.slice(-2)}`;
    });
    // Common OpenAI-style keys: sk-...
    out = out.replace(/\bsk-[A-Za-z0-9]{8,}\b/g, (m) => `${m.slice(0, 4)}****${m.slice(-2)}`);
    // Avoid leaking long tokens in error messages.
    out = out.replace(/\b[A-Za-z0-9_-]{24,}\b/g, (m) => `${m.slice(0, 3)}****${m.slice(-3)}`);
    return out;
}
function formatAgentFailureReason(error) {
    const err = error;
    const status = typeof err?.status === 'number' ? String(err.status) : '';
    const name = typeof err?.name === 'string' ? err.name : '';
    const code = typeof err?.code === 'string' ? err.code : '';
    const type = typeof err?.type === 'string' ? err.type : '';
    const rawMsg = (typeof err?.error?.message === 'string' && err.error.message) ||
        (typeof err?.message === 'string' && err.message) ||
        '';
    const compactMsg = redactSecrets(rawMsg).replace(/\s+/g, ' ').trim();
    const shortMsg = compactMsg.length > 180 ? compactMsg.slice(0, 180) + '...' : compactMsg;
    const parts = [status || name, code, type, shortMsg].filter(Boolean);
    return parts.join(' ');
}
function resolveAgentStrategy(_config) {
    const raw = (process.env.GIT_AI_AGENT_STRATEGY || '').trim().toLowerCase();
    if (raw === 'tools' || raw === 'tool' || raw === 'function' || raw === 'functions')
        return 'tools';
    if (raw === 'lite' || raw === 'local' || raw === 'fast')
        return 'lite';
    // Default: lite (fewer API calls, works for providers without tool calling).
    // Users can opt-in to tool calling with GIT_AI_AGENT_STRATEGY=tools.
    return 'lite';
}
function resolveAgentModel(config, strategy) {
    const envModel = process.env.GIT_AI_AGENT_MODEL;
    if (envModel && envModel.trim())
        return envModel.trim();
    const configured = config.agentModel;
    if (configured && configured.trim())
        return configured.trim();
    // DeepSeek reasoner models are often not tool-capable; switch to a tool-capable model only when needed.
    if (strategy === 'tools' && config.provider === 'deepseek') {
        const base = (config.model || '').trim();
        if (base.toLowerCase().includes('reasoner')) {
            return 'deepseek-chat';
        }
    }
    return config.model;
}
function isAgentDisabled() {
    return parseBooleanEnv(process.env.GIT_AI_DISABLE_AGENT) === true;
}
function isAutoAgentEnabled() {
    const raw = parseBooleanEnv(process.env.GIT_AI_AUTO_AGENT);
    if (raw === undefined)
        return true;
    return raw;
}
function stripCodeFences(text) {
    return text.replace(/^```[a-z]*\n?/i, '').replace(/```$/i, '').trim();
}
function tryParseMessagesJson(content) {
    try {
        const parsed = JSON.parse(content);
        if (Array.isArray(parsed)) {
            const arr = parsed.filter((item) => typeof item === 'string');
            return arr.map((s) => s.trim()).filter(Boolean);
        }
        if (parsed && typeof parsed === 'object') {
            const anyObj = parsed;
            if (typeof anyObj.message === 'string') {
                const msg = anyObj.message.trim();
                return msg ? [msg] : [];
            }
            if (Array.isArray(anyObj.messages)) {
                const arr = anyObj.messages.filter((item) => typeof item === 'string');
                return arr.map((s) => s.trim()).filter(Boolean);
            }
        }
    }
    catch {
        // ignore
    }
    return null;
}
const DEFAULT_COMMIT_RULES = {
    types: ['feat', 'fix', 'docs', 'style', 'refactor', 'perf', 'test', 'chore', 'build', 'ci'],
    maxSubjectLength: 50,
    requireScope: false,
    issuePattern: /([A-Z]+-\d+|#\d+)/,
    issuePlacement: 'footer',
    issueFooterPrefix: 'Refs',
    requireIssue: false,
};
const RULES_PRESETS = {
    conventional: {
        types: ['feat', 'fix', 'docs', 'style', 'refactor', 'perf', 'test', 'chore', 'build', 'ci'],
        maxSubjectLength: 50,
        requireScope: false,
    },
    angular: {
        types: ['feat', 'fix', 'docs', 'style', 'refactor', 'perf', 'test', 'build', 'ci', 'chore', 'revert'],
        maxSubjectLength: 50,
        requireScope: true,
    },
    minimal: {
        types: ['feat', 'fix', 'docs', 'refactor', 'perf', 'test', 'chore'],
        maxSubjectLength: 50,
        requireScope: false,
    },
};
export function validateCommitRules(raw) {
    const errors = [];
    const warnings = [];
    if (raw === undefined)
        return { errors, warnings };
    if (!raw || typeof raw !== 'object' || Array.isArray(raw)) {
        errors.push('rules must be an object');
        return { errors, warnings };
    }
    const rules = raw;
    if (rules.types !== undefined) {
        if (!Array.isArray(rules.types)) {
            errors.push('rules.types must be an array of strings');
        }
        else {
            const cleaned = rules.types.filter((t) => typeof t === 'string' && t.trim());
            if (cleaned.length === 0) {
                errors.push('rules.types must not be empty');
            }
            if (cleaned.length !== rules.types.length) {
                warnings.push('rules.types contains non-string entries');
            }
        }
    }
    if (rules.scopes !== undefined) {
        if (!Array.isArray(rules.scopes)) {
            errors.push('rules.scopes must be an array of strings');
        }
        else {
            const cleaned = rules.scopes.filter((s) => typeof s === 'string' && s.trim());
            if (cleaned.length !== rules.scopes.length) {
                warnings.push('rules.scopes contains non-string entries');
            }
        }
    }
    if (rules.scopeMap !== undefined) {
        if (!rules.scopeMap || typeof rules.scopeMap !== 'object' || Array.isArray(rules.scopeMap)) {
            errors.push('rules.scopeMap must be an object map of path -> scope');
        }
        else {
            const entries = Object.entries(rules.scopeMap);
            const valid = entries.filter(([k, v]) => typeof k === 'string' && k.trim() && typeof v === 'string' && v.trim());
            if (valid.length !== entries.length) {
                warnings.push('rules.scopeMap contains invalid entries');
            }
        }
    }
    if (rules.maxSubjectLength !== undefined) {
        if (typeof rules.maxSubjectLength !== 'number' || !Number.isFinite(rules.maxSubjectLength)) {
            errors.push('rules.maxSubjectLength must be a number');
        }
        else if (rules.maxSubjectLength <= 10) {
            warnings.push('rules.maxSubjectLength should be > 10');
        }
    }
    if (rules.requireScope !== undefined && typeof rules.requireScope !== 'boolean') {
        errors.push('rules.requireScope must be a boolean');
    }
    if (rules.issuePattern !== undefined) {
        if (typeof rules.issuePattern !== 'string' || !rules.issuePattern.trim()) {
            errors.push('rules.issuePattern must be a non-empty string');
        }
        else {
            try {
                // eslint-disable-next-line no-new
                new RegExp(rules.issuePattern);
            }
            catch {
                errors.push('rules.issuePattern must be a valid regex string');
            }
        }
    }
    if (rules.issuePlacement !== undefined) {
        if (rules.issuePlacement !== 'scope' &&
            rules.issuePlacement !== 'subject' &&
            rules.issuePlacement !== 'footer') {
            errors.push('rules.issuePlacement must be scope, subject, or footer');
        }
    }
    if (rules.issueFooterPrefix !== undefined && typeof rules.issueFooterPrefix !== 'string') {
        errors.push('rules.issueFooterPrefix must be a string');
    }
    if (rules.requireIssue !== undefined && typeof rules.requireIssue !== 'boolean') {
        errors.push('rules.requireIssue must be a boolean');
    }
    return { errors, warnings };
}
function normalizeRules(config) {
    const presetName = (config.rulesPreset || '').trim().toLowerCase();
    const preset = presetName ? RULES_PRESETS[presetName] : undefined;
    const custom = config.rules;
    const resolvedTypes = Array.isArray(custom?.types) && custom.types.length > 0
        ? custom.types.filter((t) => typeof t === 'string' && t.trim()).map((t) => t.trim())
        : Array.isArray(preset?.types) && preset?.types?.length
            ? preset.types
            : DEFAULT_COMMIT_RULES.types;
    const types = resolvedTypes.length ? resolvedTypes : DEFAULT_COMMIT_RULES.types;
    const scopes = Array.isArray(custom?.scopes) && custom.scopes.length > 0
        ? custom.scopes.filter((s) => typeof s === 'string' && s.trim()).map((s) => s.trim())
        : Array.isArray(preset?.scopes) && preset?.scopes?.length
            ? preset.scopes
            : undefined;
    const presetScopeMap = preset?.scopeMap && typeof preset.scopeMap === 'object'
        ? Object.fromEntries(Object.entries(preset.scopeMap).filter(([k, v]) => typeof k === 'string' && typeof v === 'string' && k.trim() && v.trim()))
        : undefined;
    const customScopeMap = custom?.scopeMap && typeof custom.scopeMap === 'object'
        ? Object.fromEntries(Object.entries(custom.scopeMap).filter(([k, v]) => typeof k === 'string' && typeof v === 'string' && k.trim() && v.trim()))
        : undefined;
    const scopeMap = presetScopeMap || customScopeMap ? { ...(presetScopeMap || {}), ...(customScopeMap || {}) } : undefined;
    const maxSubjectLength = typeof custom?.maxSubjectLength === 'number' && custom.maxSubjectLength > 10
        ? Math.floor(custom.maxSubjectLength)
        : typeof preset?.maxSubjectLength === 'number' && preset.maxSubjectLength > 10
            ? Math.floor(preset.maxSubjectLength)
            : DEFAULT_COMMIT_RULES.maxSubjectLength;
    const requireScope = typeof custom?.requireScope === 'boolean'
        ? custom.requireScope
        : typeof preset?.requireScope === 'boolean'
            ? preset.requireScope
            : DEFAULT_COMMIT_RULES.requireScope;
    const issuePatternRaw = typeof custom?.issuePattern === 'string' && custom.issuePattern.trim()
        ? custom.issuePattern.trim()
        : typeof preset?.issuePattern === 'string' && preset.issuePattern.trim()
            ? preset.issuePattern.trim()
            : undefined;
    let issuePattern = DEFAULT_COMMIT_RULES.issuePattern;
    if (issuePatternRaw) {
        try {
            issuePattern = new RegExp(issuePatternRaw);
        }
        catch {
            issuePattern = DEFAULT_COMMIT_RULES.issuePattern;
        }
    }
    const issuePlacement = custom?.issuePlacement === 'scope' ||
        custom?.issuePlacement === 'subject' ||
        custom?.issuePlacement === 'footer'
        ? custom.issuePlacement
        : preset?.issuePlacement === 'scope' ||
            preset?.issuePlacement === 'subject' ||
            preset?.issuePlacement === 'footer'
            ? preset.issuePlacement
            : DEFAULT_COMMIT_RULES.issuePlacement;
    const issueFooterPrefix = typeof custom?.issueFooterPrefix === 'string' && custom.issueFooterPrefix.trim()
        ? custom.issueFooterPrefix.trim()
        : typeof preset?.issueFooterPrefix === 'string' && preset.issueFooterPrefix.trim()
            ? preset.issueFooterPrefix.trim()
            : DEFAULT_COMMIT_RULES.issueFooterPrefix;
    const requireIssue = typeof custom?.requireIssue === 'boolean'
        ? custom.requireIssue
        : typeof preset?.requireIssue === 'boolean'
            ? preset.requireIssue
            : DEFAULT_COMMIT_RULES.requireIssue;
    return {
        types,
        scopes,
        scopeMap,
        maxSubjectLength,
        requireScope,
        issuePattern,
        issuePlacement,
        issueFooterPrefix,
        requireIssue,
    };
}
function normalizePath(path) {
    return path.replace(/\\/g, '/');
}
function inferTypeFromBranch(branchName) {
    const branch = branchName || '';
    if (/^feature\//.test(branch))
        return 'feat';
    if (/^bugfix\//.test(branch))
        return 'fix';
    if (/^hotfix\//.test(branch))
        return 'fix';
    if (/^release\//.test(branch))
        return 'chore';
    if (/^docs\//.test(branch))
        return 'docs';
    return null;
}
function inferScopeFromBranch(branchName) {
    if (!branchName)
        return null;
    const patterns = [
        /^(?:feature|bugfix|hotfix|release|dev)\/([a-zA-Z0-9_-]+)/,
        /^(?:feat|fix|chore|docs)\/([a-zA-Z0-9_-]+)/,
        /^[A-Z]+-\d+/,
    ];
    for (const pattern of patterns) {
        const match = branchName.match(pattern);
        if (match) {
            return match[1].toLowerCase().replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
        }
    }
    return null;
}
function inferScopeFromPaths(stagedFiles, scopeMap) {
    if (!stagedFiles || stagedFiles.length === 0)
        return null;
    if (scopeMap) {
        const normalizedMap = Object.entries(scopeMap)
            .map(([prefix, scope]) => [normalizePath(prefix), scope])
            .sort((a, b) => b[0].length - a[0].length);
        for (const file of stagedFiles) {
            const normalized = normalizePath(file);
            for (const [prefix, scope] of normalizedMap) {
                if (!prefix)
                    continue;
                const anchor = prefix.endsWith('/') ? prefix : `${prefix}/`;
                if (normalized.startsWith(prefix) || normalized.includes(anchor)) {
                    return scope;
                }
            }
        }
    }
    // Monorepo auto-scope (packages/apps/services/libs)
    for (const file of stagedFiles) {
        const normalized = normalizePath(file);
        const match = normalized.match(/^(?:packages|apps|services|libs)\/([^/]+)/);
        if (match) {
            return match[1];
        }
    }
    return null;
}
function pickScope(inputScope, rules, branchName, stagedFiles) {
    let scope = inputScope?.trim();
    if (!scope) {
        scope = inferScopeFromBranch(branchName) || inferScopeFromPaths(stagedFiles, rules.scopeMap) || undefined;
    }
    if (scope && rules.scopes && !rules.scopes.includes(scope)) {
        scope = undefined;
    }
    if (!scope && rules.requireScope) {
        scope = inferScopeFromBranch(branchName) || inferScopeFromPaths(stagedFiles, rules.scopeMap) || 'core';
    }
    return scope || null;
}
function normalizeType(inputType, rules, branchName) {
    const trimmed = inputType?.trim();
    if (trimmed && rules.types.includes(trimmed))
        return trimmed;
    const inferred = inferTypeFromBranch(branchName);
    if (inferred && rules.types.includes(inferred))
        return inferred;
    return rules.types[0] || 'chore';
}
function cleanSubject(subject, rules, locale) {
    let out = (subject || '').trim();
    out = out.replace(/[ã€‚.]$/, '').trim();
    if (!out) {
        out = locale === 'zh' ? 'æ›´æ–°ä»£ç ' : 'update code';
    }
    if (out.length > rules.maxSubjectLength) {
        out = out.slice(0, rules.maxSubjectLength).trim();
    }
    return out;
}
function findIssue(text, pattern) {
    if (!text)
        return null;
    const match = text.match(pattern);
    return match ? match[0] : null;
}
function resolveIssueId(message, branchName, rules) {
    const fromMessage = findIssue(message, rules.issuePattern);
    if (fromMessage)
        return { issue: fromMessage, fromMessage: true };
    const fromBranch = findIssue(branchName, rules.issuePattern);
    if (fromBranch)
        return { issue: fromBranch, fromMessage: false };
    return { issue: null, fromMessage: false };
}
function normalizeIssueId(issue, placement) {
    if (placement === 'scope') {
        return issue.replace(/^#/, '');
    }
    return issue;
}
function formatCommitMessage(type, scope, subject, locale, body, risks, footer) {
    const head = `${type}${scope ? `(${scope})` : ''}: ${subject}`;
    const bodyParts = [];
    if (body && body.trim())
        bodyParts.push(body.trim());
    if (risks && risks.trim()) {
        bodyParts.push(`${locale === 'zh' ? 'é£é™©' : 'Risks'}: ${risks.trim()}`);
    }
    if (footer && footer.trim()) {
        bodyParts.push(footer.trim());
    }
    if (bodyParts.length === 0)
        return head;
    return `${head}\n\n${bodyParts.join('\n\n')}`;
}
function enforceRulesOnTextMessage(message, rules, locale, branchName, stagedFiles) {
    const lines = message.split('\n');
    const head = lines[0]?.trim() || '';
    const body = lines.slice(1).join('\n').trim() || undefined;
    const match = head.match(/^(\w+)(?:\(([^)]+)\))?:\s*(.+)$/);
    const type = normalizeType(match?.[1], rules, branchName);
    let scope = pickScope(match?.[2], rules, branchName, stagedFiles);
    let subject = cleanSubject(match?.[3] || head, rules, locale);
    const issueInfo = resolveIssueId(message, branchName, rules);
    let footer;
    if (issueInfo.issue && !issueInfo.fromMessage) {
        const issue = normalizeIssueId(issueInfo.issue, rules.issuePlacement);
        if (rules.issuePlacement === 'scope') {
            if (!scope || scope === 'core') {
                if (!rules.scopes || rules.scopes.includes(issue)) {
                    scope = issue;
                }
                else {
                    footer = `${rules.issueFooterPrefix}: ${issueInfo.issue}`;
                }
            }
            else {
                footer = `${rules.issueFooterPrefix}: ${issueInfo.issue}`;
            }
        }
        else if (rules.issuePlacement === 'subject') {
            subject = cleanSubject(`${issue} ${subject}`, rules, locale);
        }
        else {
            footer = `${rules.issueFooterPrefix}: ${issueInfo.issue}`;
        }
    }
    return formatCommitMessage(type, scope, subject, locale, body, undefined, footer);
}
export function validateCommitMessage(message, config, context) {
    const errors = [];
    const warnings = [];
    const rules = normalizeRules(config);
    const lines = message.split('\n');
    const head = lines[0]?.trim() || '';
    const match = head.match(/^(\w+)(?:\(([^)]+)\))?:\s*(.+)$/);
    if (!match) {
        errors.push('Commit message must match "<type>(<scope>): <subject>"');
        return { errors, warnings };
    }
    const type = match[1];
    const scope = match[2];
    const subject = match[3]?.trim() || '';
    if (!rules.types.includes(type)) {
        errors.push(`type "${type}" is not allowed`);
    }
    if (rules.requireScope && (!scope || !scope.trim())) {
        errors.push('scope is required');
    }
    if (scope && rules.scopes && !rules.scopes.includes(scope)) {
        errors.push(`scope "${scope}" is not in allowed scopes`);
    }
    if (!subject) {
        errors.push('subject must not be empty');
    }
    if (subject.length > rules.maxSubjectLength) {
        errors.push(`subject exceeds max length ${rules.maxSubjectLength}`);
    }
    if (rules.requireIssue) {
        const issue = findIssue(message, rules.issuePattern) ||
            findIssue(context?.branchName, rules.issuePattern);
        if (!issue) {
            errors.push('issue id is required but not found');
        }
    }
    return { errors, warnings };
}
function parseCommitJson(normalized) {
    try {
        const parsed = JSON.parse(normalized);
        if (Array.isArray(parsed)) {
            return parsed
                .map((item) => (typeof item === 'object' && item ? item : null))
                .filter(Boolean);
        }
        if (parsed && typeof parsed === 'object') {
            return [parsed];
        }
    }
    catch {
        // ignore
    }
    return null;
}
function formatFromCommitJson(items, rules, locale, branchName, stagedFiles) {
    return items.map((item) => {
        if (item.message && typeof item.message === 'string') {
            return enforceRulesOnTextMessage(item.message, rules, locale, branchName, stagedFiles);
        }
        const type = normalizeType(item.type, rules, branchName);
        let scope = pickScope(item.scope, rules, branchName, stagedFiles);
        let subject = cleanSubject(item.subject, rules, locale);
        const raw = [item.type, item.scope, item.subject, item.body, item.risks]
            .filter((v) => typeof v === 'string' && v.trim())
            .join('\n');
        const issueInfo = resolveIssueId(raw, branchName, rules);
        let footer;
        if (issueInfo.issue && !issueInfo.fromMessage) {
            const issue = normalizeIssueId(issueInfo.issue, rules.issuePlacement);
            if (rules.issuePlacement === 'scope') {
                if (!scope || scope === 'core') {
                    if (!rules.scopes || rules.scopes.includes(issue)) {
                        scope = issue;
                    }
                    else {
                        footer = `${rules.issueFooterPrefix}: ${issueInfo.issue}`;
                    }
                }
                else {
                    footer = `${rules.issueFooterPrefix}: ${issueInfo.issue}`;
                }
            }
            else if (rules.issuePlacement === 'subject') {
                subject = cleanSubject(`${issue} ${subject}`, rules, locale);
            }
            else {
                footer = `${rules.issueFooterPrefix}: ${issueInfo.issue}`;
            }
        }
        return formatCommitMessage(type, scope, subject, locale, item.body, item.risks, footer);
    });
}
function normalizeAIError(error) {
    if (error instanceof Error) {
        const safe = redactSecrets(error.message || '');
        const e = new Error(safe);
        e.cause = error;
        return e;
    }
    return new Error(redactSecrets(String(error)));
}
function shouldFallbackFromAgent(error) {
    const err = error;
    const status = typeof err?.status === 'number' ? err.status : undefined;
    const type = typeof err?.type === 'string' ? err.type : '';
    // If auth/endpoint is wrong, basic mode will fail too: don't spam the user with a second failure.
    if (status === 401 || status === 403 || type === 'authentication_error')
        return false;
    if (status === 404)
        return false;
    // Rate limits / transient errors: agent uses more calls; basic mode may succeed.
    if (status === 429)
        return true;
    if (status && status >= 500)
        return true;
    const msg = (typeof err?.error?.message === 'string' && err.error.message) ||
        (typeof err?.message === 'string' && err.message) ||
        '';
    const lowered = String(msg).toLowerCase();
    // Tool calling compatibility issues: fall back to basic mode.
    if (lowered.includes('tool') || lowered.includes('tool_choice') || lowered.includes('function'))
        return true;
    // Default: keep previous behavior (fallback), unless it's clearly an auth/endpoint issue.
    return true;
}
function shouldFallbackModel(error) {
    const err = error;
    const status = typeof err?.status === 'number' ? err.status : undefined;
    const type = typeof err?.type === 'string' ? err.type : '';
    if (status === 401 || status === 403 || type === 'authentication_error')
        return false;
    if (status === 404)
        return false;
    if (status === 429)
        return true;
    if (status && status >= 500)
        return true;
    const msg = (typeof err?.error?.message === 'string' && err.error.message) ||
        (typeof err?.message === 'string' && err.message) ||
        '';
    const lowered = String(msg).toLowerCase();
    if (lowered.includes('timeout') || lowered.includes('timed out'))
        return true;
    if (lowered.includes('rate limit'))
        return true;
    return false;
}
const DEFAULT_SYSTEM_PROMPT_EN = `You are an expert at writing Git commit messages following the Conventional Commits specification.

Based on the git diff provided, generate a concise and descriptive commit message.

Rules:
1. Use the format: <type>(<scope>): <subject>
2. Types: feat, fix, docs, style, refactor, perf, test, chore, build, ci
3. Keep the subject line under 50 characters
4. Use imperative mood ("add" not "added")
5. Don't end the subject line with a period
6. If needed, add a blank line followed by a body for more details
7. Git Flow Branch Mapping (Priority):
   - feature/* -> type: feat
   - bugfix/* -> type: fix
   - hotfix/* -> type: fix
   - release/* -> type: chore
    - docs/* -> type: docs
    - If branch name matches, infer <scope> from it (e.g. feature/login -> feat(login): ...)
    - If branch name doesn't match these patterns, ignore it and infer type/scope strictly from the code changes.

Only output the commit message, nothing else.`;
const DEFAULT_SYSTEM_PROMPT_ZH = `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ Git commit message ç¼–å†™ä¸“å®¶ï¼Œéµå¾ª Conventional Commits è§„èŒƒã€‚

æ ¹æ®æä¾›çš„ git diffï¼Œç”Ÿæˆç®€æ´ä¸”æè¿°æ€§çš„æäº¤ä¿¡æ¯ã€‚

è§„åˆ™ï¼š
1. ä½¿ç”¨æ ¼å¼: <type>(<scope>): <subject>
2. type ç±»å‹: feat, fix, docs, style, refactor, perf, test, chore, build, ci
3. subject ä¿æŒåœ¨ 50 å­—ç¬¦ä»¥å†…
4. ä½¿ç”¨ç¥ˆä½¿è¯­æ°”
5. subject æœ«å°¾ä¸è¦åŠ å¥å·
6. å¦‚éœ€è¦ï¼Œç©ºä¸€è¡Œåæ·»åŠ  body æä¾›æ›´å¤šç»†èŠ‚
7. Git Flow åˆ†æ”¯æ˜ å°„è§„åˆ™ (ä¼˜å…ˆçº§æœ€é«˜):
   - feature/* -> type: feat
   - bugfix/* -> type: fix
   - hotfix/* -> type: fix
   - release/* -> type: chore
   - docs/* -> type: docs
   - å¦‚æœåˆ†æ”¯ååŒ¹é…ï¼Œè¯·ä»ä¸­æ¨æ–­ <scope> (ä¾‹å¦‚: feature/login -> feat(login): ...)
   - å¦‚æœåˆ†æ”¯åä¸ç¬¦åˆä¸Šè¿°æ ‡å‡†å‰ç¼€ï¼Œè¯·å¿½ç•¥åˆ†æ”¯åï¼Œä»…ä¾æ®ä»£ç å˜æ›´å†…å®¹(diff)æ¥å†³å®š type å’Œ scopeã€‚

åªè¾“å‡º commit messageï¼Œä¸è¦è¾“å‡ºå…¶ä»–å†…å®¹ã€‚`;
const DEEPSEEK_PROMPT_ZH = `ä½ æ˜¯ä¸€ä¸ªæ™ºèƒ½ç¼–ç¨‹åŠ©æ‰‹ï¼Œä¸“æ³¨äºç”Ÿæˆé«˜è´¨é‡çš„ Git æäº¤ä¿¡æ¯ã€‚

è¯·ä»”ç»†åˆ†æä¸‹æ–¹çš„ Git Diffï¼Œç†è§£ä»£ç å˜æ›´çš„*æ„å›¾*ï¼ˆä¸ä»…ä»…æ˜¯ä¿®æ”¹äº†ä»€ä¹ˆï¼‰ã€‚

è§„åˆ™ï¼š
1. ä¸¥æ ¼éµå¾ª Conventional Commits è§„èŒƒ: <type>(<scope>): <subject>
2. ç±»å‹(type)å¿…é¡»æ˜¯: feat, fix, docs, style, refactor, perf, test, chore, build, ci
3. æè¿°(subject)éœ€ç®€æ´æœ‰åŠ›ï¼Œ50å­—ç¬¦ä»¥å†…ï¼Œä½¿ç”¨ä¸­æ–‡ã€‚
4. å¦‚æœå˜æ›´å¤æ‚ï¼Œè¯·åœ¨ subject åç©ºä¸€è¡Œï¼Œæ·»åŠ è¯¦ç»†çš„ body è¯´æ˜ã€‚
5. ä¸“æ³¨äº*ä¸ºä»€ä¹ˆ*å˜æ›´ï¼Œè€Œä¸ä»…ä»…æ˜¯*æ”¹äº†ä»€ä¹ˆ*ã€‚
6. Git Flow åˆ†æ”¯æ˜ å°„è§„åˆ™ (ä¼˜å…ˆçº§æœ€é«˜):
   - feature/* -> type: feat
   - bugfix/* -> type: fix
   - hotfix/* -> type: fix
   - release/* -> type: chore
   - docs/* -> type: docs
   - å¦‚æœåˆ†æ”¯ååŒ¹é…ï¼Œè¯·ä»ä¸­æ¨æ–­ <scope> (ä¾‹å¦‚: feature/login -> feat(login): ...)
   - å¦‚æœåˆ†æ”¯åä¸ç¬¦åˆä¸Šè¿°æ ‡å‡†å‰ç¼€ï¼Œè¯·å¿½ç•¥åˆ†æ”¯åï¼Œä»…ä¾æ®ä»£ç å˜æ›´å†…å®¹(diff)æ¥å†³å®š type å’Œ scopeã€‚

åªè¾“å‡ºæœ€ç»ˆçš„ Commit Messageï¼Œä¸åŒ…å« Markdown ä»£ç å—æˆ–å…¶ä»–è§£é‡Šã€‚`;
export function createAIClient(config) {
    return new OpenAI({
        apiKey: config.apiKey || 'ollama',
        baseURL: config.baseUrl,
        timeout: getTimeoutMs(),
        maxRetries: 2, // Built-in retry support
    });
}
export async function generateCommitMessage(client, input, config, numChoices = 1) {
    let diff = input.diff;
    let ignoredFiles = input.ignoredFiles;
    let truncated = input.truncated;
    const rules = normalizeRules(config);
    const outputFormat = config.outputFormat || 'text';
    const ensureDiff = async () => {
        if (diff !== undefined)
            return;
        if (input.diffLoader) {
            const loaded = await input.diffLoader();
            diff = loaded.diff;
            truncated = loaded.truncated;
            ignoredFiles = loaded.ignoredFiles;
            return;
        }
        diff = '';
    };
    // Auto-enable Agent for critical branches in Git Flow
    // Critical: release/hotfix/master/main - always use Agent
    // Feature: feature/*/bugfix/*/dev/* - use Agent for impact analysis
    const branch = input.branchName || '';
    const isCriticalBranch = /^(release|hotfix)\//.test(branch) || /^(master|main)$/.test(branch);
    const isFeatureBranch = /^(feature|bugfix|dev)\//.test(branch);
    const autoAgentEnabled = isAutoAgentEnabled();
    const agentDisabled = isAgentDisabled();
    const shouldRunAgent = !agentDisabled &&
        (input.forceAgent || (autoAgentEnabled && (input.truncated || isCriticalBranch || isFeatureBranch))) &&
        numChoices === 1;
    // Trigger Agent Mode if diff is truncated OR forced by user OR critical branch
    if (shouldRunAgent) {
        try {
            const stats = await getFileStats();
            if (stats.length > 0) {
                const agentStrategy = resolveAgentStrategy(config);
                const agentModel = resolveAgentModel(config, agentStrategy);
                if (!input.quiet) {
                    const label = agentStrategy === 'tools' ? 'tools' : 'lite';
                    if (agentModel !== config.model) {
                        console.log(chalk.gray(`\nğŸ§  Agent (${label}) model: ${agentModel} (base model: ${config.model})`));
                    }
                    else {
                        console.log(chalk.gray(`\nğŸ§  Agent strategy: ${label}`));
                    }
                }
                const agentMessage = agentStrategy === 'tools'
                    ? await runAgentLoop(client, config, stats, input.branchName, input.quiet, agentModel)
                    : await runAgentLite(client, config, stats, input.branchName, input.quiet, agentModel);
                const enforced = enforceRulesOnTextMessage(agentMessage, rules, config.locale, input.branchName, input.stagedFiles);
                const out = config.enableFooter ? `${enforced}\n\nğŸ¤– Generated by git-ai ğŸš€` : enforced;
                return [out];
            }
        }
        catch (error) {
            if (!shouldFallbackFromAgent(error)) {
                throw normalizeAIError(error);
            }
            if (!input.quiet) {
                const reason = formatAgentFailureReason(error);
                const suffix = reason ? ` (${reason})` : '';
                console.error(chalk.yellow(`\nâš ï¸  Agent mode failed${suffix}, falling back to basic mode...`));
                if (process.env.GIT_AI_DEBUG === '1') {
                    console.error(error);
                }
            }
        }
    }
    await ensureDiff();
    let systemPrompt = config.customPrompt;
    if (!systemPrompt) {
        const isZh = config.locale === 'zh';
        if (config.provider === 'deepseek' || config.provider === 'qwen') {
            systemPrompt = isZh ? DEEPSEEK_PROMPT_ZH : DEFAULT_SYSTEM_PROMPT_EN; // Reuse EN for now or add DeepSeek EN later
        }
        else {
            systemPrompt = isZh ? DEFAULT_SYSTEM_PROMPT_ZH : DEFAULT_SYSTEM_PROMPT_EN;
        }
    }
    const isZh = config.locale === 'zh';
    const lines = [];
    const rulesHeader = isZh ? 'Commit è§„åˆ™:' : 'Commit rules:';
    const rulesLines = [
        `${rulesHeader}`,
        `types: ${rules.types.join(', ')}`,
        `maxSubjectLength: ${rules.maxSubjectLength}`,
        `requireScope: ${rules.requireScope ? 'true' : 'false'}`,
        `issuePlacement: ${rules.issuePlacement}`,
        `requireIssue: ${rules.requireIssue ? 'true' : 'false'}`,
        `issuePattern: ${rules.issuePattern.source}`,
        `issueFooterPrefix: ${rules.issueFooterPrefix}`,
    ];
    if (rules.scopes && rules.scopes.length) {
        rulesLines.push(`scopes: ${rules.scopes.join(', ')}`);
    }
    lines.push(rulesLines.join('\n'));
    if (numChoices > 1) {
        // Add instruction for multiple choices (JSON array for robustness)
        const multiInstruction = outputFormat === 'json'
            ? isZh
                ? `\nè¯·ä»…è¾“å‡º JSON æ•°ç»„ï¼ŒåŒ…å« ${numChoices} ä¸ªå¯¹è±¡ï¼Œæ¯ä¸ªå¯¹è±¡å­—æ®µä¸º type, scope, subject, body?, risks?ï¼›ä¸è¦è¾“å‡ºå…¶ä»–å†…å®¹ã€‚`
                : `\nRespond with a JSON array of ${numChoices} objects with fields type, scope, subject, body?, risks?. Output JSON only.`
            : isZh
                ? `\nè¯·ä»…è¾“å‡º JSON æ•°ç»„ï¼ŒåŒ…å« ${numChoices} æ¡ä¸åŒçš„ commit messageï¼ˆå­—ç¬¦ä¸²æ•°ç»„ï¼‰ï¼Œä¸è¦è¾“å‡ºå…¶ä»–å†…å®¹ã€‚`
                : `\nRespond with a JSON array of ${numChoices} distinct commit message strings. Output JSON only.`;
        systemPrompt += multiInstruction;
    }
    else if (outputFormat === 'json') {
        const singleInstruction = isZh
            ? `\nè¯·ä»…è¾“å‡ºä¸€ä¸ª JSON å¯¹è±¡ï¼Œå­—æ®µä¸º type, scope, subject, body?, risks?ï¼›ä¸è¦è¾“å‡ºå…¶ä»–å†…å®¹ã€‚`
            : `\nRespond with a single JSON object with fields type, scope, subject, body?, risks?. Output JSON only.`;
        systemPrompt += singleInstruction;
    }
    if (input.recentCommits?.length) {
        const header = isZh
            ? 'å‚è€ƒå†å²æäº¤é£æ ¼ (è¯·æ¨¡ä»¿ä»¥ä¸‹é£æ ¼):'
            : 'Reference recent commits (please mimic the style):';
        // Extract subject from "hash date subject" format
        // Format is "%h %cd %s", so we take everything after the second space
        const cleanCommits = input.recentCommits
            .map((line) => {
            const parts = line.split(' ');
            if (parts.length >= 3) {
                return parts.slice(2).join(' ');
            }
            return line;
        })
            .slice(0, 10); // Limit to 10 to save tokens
        lines.push(`${header}\n${cleanCommits.map((c) => `- ${c}`).join('\n')}`);
    }
    if (input.branchName) {
        const header = isZh ? 'å½“å‰åˆ†æ”¯:' : 'Current branch:';
        lines.push(`${header} ${input.branchName}`);
    }
    if (input.stagedFiles?.length) {
        const header = isZh ? 'å·²æš‚å­˜æ–‡ä»¶:' : 'Staged files:';
        lines.push(`${header}\n${input.stagedFiles.map((f) => `- ${f}`).join('\n')}`);
    }
    if (ignoredFiles?.length) {
        const header = isZh
            ? 'ä»¥ä¸‹æ–‡ä»¶ä¸ºèŠ‚çœ Token å·²å¿½ç•¥ Diff:'
            : 'Ignored files (diff omitted for token optimization):';
        lines.push(`${header}\n${ignoredFiles.map((f) => `- ${f}`).join('\n')}`);
    }
    if (truncated) {
        lines.push(isZh
            ? 'æ³¨æ„ï¼šDiff å†…å®¹å·²å› é•¿åº¦é™åˆ¶è¢«æˆªæ–­ã€‚'
            : 'Note: The diff was truncated due to size limits.');
    }
    const diffHeader = isZh ? 'Git Diff:' : 'Git diff:';
    lines.push(`${diffHeader}\n\n${diff || '(empty)'}`);
    const modelCandidates = getModelCandidates(config);
    let response = null;
    let lastError = null;
    for (const model of modelCandidates) {
        try {
            response = await client.chat.completions.create({
                model,
                messages: [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: lines.join('\n\n') },
                ],
                temperature: 0.7,
                max_tokens: getMaxOutputTokens(numChoices),
            });
            break;
        }
        catch (error) {
            lastError = error;
            if (!shouldFallbackModel(error) || model === modelCandidates[modelCandidates.length - 1]) {
                throw normalizeAIError(error);
            }
            if (process.env.GIT_AI_DEBUG === '1') {
                console.error(chalk.yellow(`âš ï¸  Model ${model} failed, trying fallback...`));
            }
        }
    }
    if (!response) {
        throw normalizeAIError(lastError);
    }
    const content = response.choices[0]?.message?.content?.trim();
    if (!content) {
        throw new Error('Failed to generate commit message: empty response');
    }
    const normalized = stripCodeFences(content);
    let messages = [];
    if (outputFormat === 'json') {
        const parsed = parseCommitJson(normalized);
        if (parsed && parsed.length) {
            messages = formatFromCommitJson(parsed, rules, config.locale, input.branchName, input.stagedFiles);
        }
        else {
            const fallback = tryParseMessagesJson(normalized);
            const rawMessages = fallback && fallback.length ? fallback : [normalized];
            messages = rawMessages.map((msg) => enforceRulesOnTextMessage(msg, rules, config.locale, input.branchName, input.stagedFiles));
        }
    }
    else {
        if (numChoices > 1) {
            const parsed = tryParseMessagesJson(normalized);
            if (parsed && parsed.length) {
                messages = parsed;
            }
            else {
                messages = normalized
                    .split('---')
                    .map((msg) => msg.trim())
                    .filter(Boolean);
            }
        }
        else {
            const parsed = tryParseMessagesJson(normalized);
            if (parsed && parsed.length === 1) {
                messages = parsed;
            }
            else {
                messages = [normalized];
            }
        }
        messages = messages.map((msg) => enforceRulesOnTextMessage(msg, rules, config.locale, input.branchName, input.stagedFiles));
    }
    if (config.enableFooter) {
        return messages.map((msg) => `${msg}\n\nğŸ¤– Generated by git-ai ğŸš€`);
    }
    return messages;
}
const REPORT_PROMPT_ZH = `ä½ æ˜¯ä¸€ä½èµ„æ·±æŠ€æœ¯ä¸“å®¶ï¼Œæ“…é•¿æ’°å†™é«˜è´¨é‡çš„å‘¨æŠ¥/æ—¥æŠ¥ã€‚

è¯·æ ¹æ®æä¾›çš„ Git Commit è®°å½•ï¼Œæ•´ç†å‡ºä¸€ä»½ç»“æ„æ¸…æ™°ã€é‡ç‚¹çªå‡ºçš„å·¥ä½œæ±‡æŠ¥ã€‚

è§„åˆ™ï¼š
1. **åˆ†ç±»æ±‡æ€»**ï¼šå°†æäº¤è®°å½•å½’ç±»ï¼ˆä¾‹å¦‚ï¼šâœ¨ æ–°ç‰¹æ€§ã€ğŸ› é—®é¢˜ä¿®å¤ã€âš¡ï¸ æ€§èƒ½ä¼˜åŒ–ã€ğŸ“ æ–‡æ¡£ä¸å…¶ä»–ï¼‰ã€‚
2. **ä»·å€¼å¯¼å‘**ï¼šä¸è¦åªç½—åˆ—ä»£ç å˜æ›´ï¼Œå°è¯•ç”¨ç®€ç»ƒçš„è¯­è¨€æè¿°ä¸šåŠ¡ä»·å€¼æˆ–æŠ€æœ¯æˆæœã€‚
3. **æ ¼å¼ç¾è§‚**ï¼šä½¿ç”¨ Markdown æ ¼å¼ï¼Œåˆ©ç”¨åˆ—è¡¨å’Œ emoji è®©é˜…è¯»ä½“éªŒæ›´ä½³ã€‚
4. **è¿‡æ»¤å™ªéŸ³**ï¼šå¿½ç•¥æ— æ„ä¹‰çš„æµ‹è¯•æäº¤æˆ–ä¸´æ—¶æäº¤ã€‚

è¾“å‡ºæ ¼å¼ç¤ºä¾‹ï¼š
## ğŸ“… å·¥ä½œæ±‡æŠ¥ (Time Range)

### âœ¨ æ ¸å¿ƒäº§å‡º
- **åŠŸèƒ½ A**: å®Œæˆäº†...é€»è¾‘ï¼Œæå‡äº†...ä½“éªŒ
- **åŠŸèƒ½ B**: ...

### ğŸ› é—®é¢˜ä¿®å¤
- ä¿®å¤äº†...å¯¼è‡´çš„å´©æºƒé—®é¢˜

### ğŸ“ å…¶ä»–
- ...

(ç»“å°¾å¯åŠ ä¸€å¥ä¸‹å‘¨è®¡åˆ’å»ºè®®)`;
const REPORT_PROMPT_EN = `You are a senior technical lead expert at writing professional progress reports.

Based on the provided Git Commit logs, generate a structured and high-quality status report.

Rules:
1. **Categorize**: Group commits logically (e.g., âœ¨ Features, ğŸ› Bug Fixes, âš¡ï¸ Improvements, ğŸ“ Other).
2. **Value-Driven**: Don't just list technical changes; briefly emphasize the value or outcome.
3. **Formatting**: Use Markdown with bullet points and emojis.
4. **Filter Noise**: Ignore trivial or "wip" commits.

Output structured markdown text only.`;
const PR_PROMPT_EN = `You are a senior engineer writing a pull request description.

Based on the commit list and diff summary, produce a concise PR description.

Rules:
1) Use Markdown
2) Include sections: Summary, Changes, Testing, Risks
3) Be concise and value-focused
4) If testing info is unknown, write "Not run"

Output Markdown only.`;
const PR_PROMPT_ZH = `ä½ æ˜¯èµ„æ·±å·¥ç¨‹å¸ˆï¼Œè´Ÿè´£æ’°å†™ PR æè¿°ã€‚

æ ¹æ®æäº¤è®°å½•å’Œ diff æ¦‚è¦ï¼Œç”Ÿæˆç®€æ´çš„ PR æè¿°ã€‚

è§„åˆ™ï¼š
1) ä½¿ç”¨ Markdown
2) åŒ…å«æ¿å—ï¼šSummary, Changes, Testing, Risks
3) èšç„¦ä»·å€¼ä¸å½±å“ï¼Œé¿å…å•°å—¦
4) å¦‚æœªçŸ¥æµ‹è¯•æƒ…å†µï¼Œå†™ "Not run"

ä»…è¾“å‡º Markdownã€‚`;
const RELEASE_PROMPT_EN = `You are a release manager writing release notes.

Based on the commit list, generate structured release notes.

Rules:
1) Use Markdown
2) Group changes by type (Features, Fixes, Improvements, Docs/Chore)
3) Be concise and user-facing when possible
4) Exclude trivial/wip commits

Output Markdown only.`;
const RELEASE_PROMPT_ZH = `ä½ æ˜¯å‘å¸ƒè´Ÿè´£äººï¼Œè´Ÿè´£æ’°å†™ Release Notesã€‚

æ ¹æ®æäº¤è®°å½•ç”Ÿæˆç»“æ„åŒ–çš„å‘å¸ƒè¯´æ˜ã€‚

è§„åˆ™ï¼š
1) ä½¿ç”¨ Markdown
2) æŒ‰ç±»å‹åˆ†ç»„ï¼ˆFeatures / Fixes / Improvements / Docs/Choreï¼‰
3) å°½é‡é¢å‘ç”¨æˆ·ä»·å€¼è¡¨è¾¾
4) è¿‡æ»¤æ— æ„ä¹‰æäº¤

ä»…è¾“å‡º Markdownã€‚`;
export async function generatePullRequestDescription(client, input, config) {
    const isZh = config.locale === 'zh';
    const systemPrompt = isZh ? PR_PROMPT_ZH : PR_PROMPT_EN;
    const diffBlock = input.diffStat ? `\nDiff Summary:\n${input.diffStat}` : '';
    const modelCandidates = getModelCandidates(config);
    let result = null;
    let lastError = null;
    for (const model of modelCandidates) {
        try {
            result = await client.chat.completions.create({
                model,
                messages: [
                    { role: 'system', content: systemPrompt },
                    {
                        role: 'user',
                        content: `Base: ${input.base}\nHead: ${input.head}\nCommits:\n${input.commits.join('\n')}${diffBlock}`,
                    },
                ],
                temperature: 0.4,
            });
            break;
        }
        catch (error) {
            lastError = error;
            if (!shouldFallbackModel(error) || model === modelCandidates[modelCandidates.length - 1]) {
                throw normalizeAIError(error);
            }
        }
    }
    if (!result)
        throw normalizeAIError(lastError);
    return result.choices[0]?.message?.content?.trim() || '';
}
export async function generateReleaseNotes(client, input, config) {
    const isZh = config.locale === 'zh';
    const systemPrompt = isZh ? RELEASE_PROMPT_ZH : RELEASE_PROMPT_EN;
    const modelCandidates = getModelCandidates(config);
    let result = null;
    let lastError = null;
    for (const model of modelCandidates) {
        try {
            result = await client.chat.completions.create({
                model,
                messages: [
                    { role: 'system', content: systemPrompt },
                    {
                        role: 'user',
                        content: `Range: ${input.from} â†’ ${input.to}\nCommits:\n${input.commits.join('\n')}`,
                    },
                ],
                temperature: 0.4,
            });
            break;
        }
        catch (error) {
            lastError = error;
            if (!shouldFallbackModel(error) || model === modelCandidates[modelCandidates.length - 1]) {
                throw normalizeAIError(error);
            }
        }
    }
    if (!result)
        throw normalizeAIError(lastError);
    return result.choices[0]?.message?.content?.trim() || '';
}
export async function generateWeeklyReport(client, commits, config) {
    const isZh = config.locale === 'zh';
    const systemPrompt = isZh ? REPORT_PROMPT_ZH : REPORT_PROMPT_EN;
    if (commits.length === 0) {
        return isZh ? 'è¿™æ®µæ—¶é—´æ²¡æœ‰æ‰¾åˆ°æ‚¨çš„æäº¤è®°å½•ã€‚' : 'No commits found for this period.';
    }
    const modelCandidates = getModelCandidates(config);
    let result = null;
    let lastError = null;
    for (const model of modelCandidates) {
        try {
            result = await client.chat.completions.create({
                model,
                messages: [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: `Commit History:\n${commits.join('\n')}` },
                ],
                temperature: 0.7,
            });
            break;
        }
        catch (error) {
            lastError = error;
            if (!shouldFallbackModel(error) || model === modelCandidates[modelCandidates.length - 1]) {
                throw normalizeAIError(error);
            }
        }
    }
    if (!result) {
        throw normalizeAIError(lastError);
    }
    return result.choices[0]?.message?.content?.trim() || '';
}
//# sourceMappingURL=ai.js.map