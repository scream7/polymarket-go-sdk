import inquirer from 'inquirer';
import chalk from 'chalk';
import ora from 'ora';
import { getConfig, getLocalConfigError } from '../utils/config.js';
import { isGitInstalled, isInGitRepo, getStagedFiles, getFilteredDiff, commit, getBranchName, getRecentCommits, getUnstagedFileEntries, addFiles, } from '../utils/git.js';
import { createAIClient, generateCommitMessage, validateCommitRules, validateCommitMessage, } from '../utils/ai.js';
function exitWithError(message, hint, silent = false) {
    if (!silent) {
        console.error(chalk.red(`âŒ ${message}`));
        if (hint) {
            console.log(chalk.gray(`   ${hint}`));
        }
    }
    process.exit(1);
}
export async function runCommit(options = {}) {
    const { autoCommit = false, numChoices = 1, hookMode = false, locale } = options;
    // Recursion guard - prevent hook from triggering another git-ai
    if (process.env.GIT_AI_RUNNING === '1') {
        if (!hookMode) {
            console.log(chalk.yellow('âš ï¸  git-ai is already running (recursion prevented)'));
        }
        process.exit(0);
    }
    process.env.GIT_AI_RUNNING = '1';
    // Environment checks
    if (!(await isGitInstalled())) {
        exitWithError('Git is not installed. Please install git first.', undefined, hookMode);
    }
    if (!(await isInGitRepo())) {
        exitWithError('Not in a git repository.', undefined, hookMode);
    }
    let stagedFiles = await getStagedFiles();
    if (stagedFiles.length === 0) {
        // Interactive add
        const unstagedEntries = await getUnstagedFileEntries();
        if (unstagedEntries.length > 0 && !hookMode) {
            console.log(chalk.yellow('âš ï¸  No staged changes found.'));
            const allPaths = unstagedEntries.map((entry) => entry.path);
            const choices = [
                { name: 'âœ… Stage all files', value: '__ALL__' },
                ...unstagedEntries.map((entry) => ({
                    name: `${entry.status.replace(/ /g, '.')} ${entry.path}`,
                    value: entry.path,
                })),
            ];
            const { selectedFiles } = await inquirer.prompt([
                {
                    type: 'checkbox',
                    name: 'selectedFiles',
                    message: 'Select files to stage:',
                    choices,
                    pageSize: 15,
                },
            ]);
            if (selectedFiles.length > 0) {
                const finalSelection = selectedFiles.includes('__ALL__') ? allPaths : selectedFiles;
                await addFiles(finalSelection);
                stagedFiles = await getStagedFiles();
                console.log(chalk.green(`âœ… Staged ${finalSelection.length} files.`));
            }
            else {
                console.log(chalk.gray('No files selected. Exiting.'));
                process.exit(0);
            }
        }
        else {
            exitWithError('No staged changes found.', 'Use `git add <files>` to stage your changes first.', hookMode);
        }
    }
    // Check config
    const config = getConfig();
    if (!config) {
        const localError = getLocalConfigError();
        const hint = localError
            ? `Invalid local config at ${localError.path}: ${localError.error}`
            : 'Run `git-ai config` to set up your AI provider.';
        exitWithError('Configuration not found.', hint);
    }
    const localConfigError = getLocalConfigError();
    if (localConfigError && !hookMode) {
        console.log(chalk.yellow(`âš ï¸  Failed to parse ${localConfigError.path}: ${localConfigError.error}`));
    }
    const rulesIssues = validateCommitRules(config.rules);
    if ((rulesIssues.errors.length || rulesIssues.warnings.length) && !hookMode) {
        const combined = [...rulesIssues.errors, ...rulesIssues.warnings];
        console.log(chalk.yellow(`âš ï¸  Rules config issues: ${combined.join('; ')}`));
    }
    // Override locale if provided
    if (locale && (locale === 'zh' || locale === 'en')) {
        config.locale = locale;
    }
    // Show staged files (skip in hook mode)
    if (!hookMode) {
        console.log(chalk.cyan('\nðŸ“ Staged files:'));
        stagedFiles.forEach((file) => {
            console.log(chalk.gray(`   ${file}`));
        });
    }
    const branchName = await getBranchName();
    const recentCommits = await getRecentCommits(10); // Get last 10 commits for style reference
    const policyStrict = config.policy?.strict === true;
    let diffCache = null;
    let diffInfoPrinted = false;
    const maybePrintDiffInfo = (ignoredFiles, truncated) => {
        if (hookMode || diffInfoPrinted)
            return;
        if (ignoredFiles.length > 0) {
            const preview = ignoredFiles.slice(0, 8).join(', ');
            const more = ignoredFiles.length > 8 ? ` (+${ignoredFiles.length - 8} more)` : '';
            console.log(chalk.gray(`\nðŸ“¦ Ignored from diff (token optimization): ${preview}${more}`));
        }
        if (truncated) {
            console.log(chalk.yellow('\nâš ï¸  Diff was truncated due to size limits.'));
            console.log(chalk.gray('   Tip: add large files to .git-aiignore or set GIT_AI_MAX_DIFF_CHARS / OCO_TOKENS_MAX_INPUT.'));
        }
        diffInfoPrinted = true;
    };
    const loadDiff = async () => {
        if (!diffCache) {
            diffCache = await getFilteredDiff(stagedFiles);
            maybePrintDiffInfo(diffCache.ignoredFiles, diffCache.truncated);
        }
        return diffCache;
    };
    const shouldLazyDiff = options.agentMode && numChoices === 1;
    let diff;
    let ignoredFiles;
    let truncated;
    let diffLoader;
    if (shouldLazyDiff) {
        diffLoader = loadDiff;
    }
    else {
        const loaded = await loadDiff();
        diff = loaded.diff;
        ignoredFiles = loaded.ignoredFiles;
        truncated = loaded.truncated;
    }
    // Create AI client
    const client = createAIClient(config);
    const input = {
        diff,
        diffLoader,
        stagedFiles,
        ignoredFiles,
        truncated,
        branchName,
        recentCommits,
        forceAgent: options.agentMode,
    };
    // Generate commit message(s)
    let commitMessage;
    if (hookMode) {
        // Hook mode: silent generation, output only the message
        try {
            const messages = await generateCommitMessage(client, input, config);
            commitMessage = messages[0];
            console.log(commitMessage);
            return;
        }
        catch {
            process.exit(1);
        }
    }
    if (numChoices > 1) {
        // Generate multiple choices
        const messages = await generateMultipleWithSpinner(client, input, config, numChoices);
        if (autoCommit) {
            // Auto mode: use first message
            commitMessage = messages[0];
        }
        else {
            commitMessage = await selectFromChoices(messages);
        }
    }
    else {
        commitMessage = await generateWithSpinner(client, input, config);
    }
    // Auto commit mode
    if (autoCommit) {
        console.log(chalk.green('\nâœ¨ Generated commit message:\n'));
        console.log(chalk.white.bold(`   ${commitMessage.split('\n').join('\n   ')}`));
        const validation = validateCommitMessage(commitMessage, config, { branchName, stagedFiles });
        if (validation.errors.length) {
            const msg = `Commit policy violation: ${validation.errors.join('; ')}`;
            if (policyStrict) {
                exitWithError(msg);
            }
            else {
                console.log(chalk.yellow(`âš ï¸  ${msg}`));
            }
        }
        await performCommit(commitMessage);
        return;
    }
    // Interactive loop
    while (true) {
        console.log(chalk.green('\nâœ¨ Generated commit message:\n'));
        console.log(chalk.white.bold(`   ${commitMessage.split('\n').join('\n   ')}`));
        console.log('');
        const { action } = await inquirer.prompt([
            {
                type: 'list',
                name: 'action',
                message: 'What would you like to do?',
                choices: [
                    { name: 'ðŸš€ Commit', value: 'commit' },
                    { name: 'ðŸ“ Edit', value: 'edit' },
                    { name: 'ðŸ”„ Regenerate', value: 'regenerate' },
                    { name: 'âŒ Cancel', value: 'cancel' },
                ],
            },
        ]);
        if (action === 'commit') {
            const validation = validateCommitMessage(commitMessage, config, { branchName, stagedFiles });
            if (validation.errors.length) {
                const msg = `Commit policy violation: ${validation.errors.join('; ')}`;
                if (policyStrict) {
                    console.log(chalk.red(`âŒ ${msg}`));
                    continue;
                }
                console.log(chalk.yellow(`âš ï¸  ${msg}`));
            }
            await performCommit(commitMessage);
            break;
        }
        else if (action === 'edit') {
            const { editedMessage } = await inquirer.prompt([
                {
                    type: 'editor',
                    name: 'editedMessage',
                    message: 'Edit your commit message:',
                    default: commitMessage,
                },
            ]);
            commitMessage = editedMessage.trim();
            if (!commitMessage) {
                console.log(chalk.yellow('âš ï¸  Commit message cannot be empty.'));
                continue;
            }
        }
        else if (action === 'regenerate') {
            if (numChoices > 1) {
                const messages = await generateMultipleWithSpinner(client, input, config, numChoices);
                commitMessage = await selectFromChoices(messages);
            }
            else {
                commitMessage = await generateWithSpinner(client, input, config);
            }
        }
        else {
            console.log(chalk.gray('\nðŸ‘‹ Commit cancelled.\n'));
            break;
        }
    }
}
async function selectFromChoices(messages) {
    if (messages.length === 1) {
        return messages[0];
    }
    const { selected } = await inquirer.prompt([
        {
            type: 'list',
            name: 'selected',
            message: 'Select a commit message:',
            choices: messages.map((msg, i) => ({
                name: `${i + 1}. ${msg.split('\n')[0]}`,
                value: msg,
            })),
        },
    ]);
    return selected;
}
async function generateWithSpinner(client, input, config) {
    const spinner = ora({
        text: 'Generating commit message...',
        color: 'cyan',
    }).start();
    try {
        const messages = await generateCommitMessage(client, input, config);
        spinner.succeed('Commit message generated!');
        return messages[0];
    }
    catch (error) {
        spinner.fail('Failed to generate commit message');
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        exitWithError(errorMessage);
    }
}
async function generateMultipleWithSpinner(client, input, config, count) {
    const spinner = ora({
        text: `Generating ${count} commit messages...`,
        color: 'cyan',
    }).start();
    try {
        // Optimized: Single request for multiple choices
        const messages = await generateCommitMessage(client, input, config, count);
        // Dedupe
        const unique = [...new Set(messages)];
        spinner.succeed(`Generated ${unique.length} commit message(s)!`);
        return unique;
    }
    catch (error) {
        spinner.fail('Failed to generate commit messages');
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        exitWithError(errorMessage);
    }
}
async function performCommit(message) {
    const spinner = ora({
        text: 'Creating commit...',
        color: 'cyan',
    }).start();
    try {
        await commit(message);
        spinner.succeed('Commit created successfully!');
        console.log(chalk.green('\nðŸŽ‰ Done!\n'));
    }
    catch (error) {
        spinner.fail('Failed to create commit');
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        exitWithError(errorMessage);
    }
}
//# sourceMappingURL=commit.js.map