import { cac } from 'cac';
import chalk from 'chalk';
import { createRequire } from 'node:module';
import { runConfig } from './commands/config.js';
import { runConfigDescribe, runConfigGet, runConfigSet } from './commands/config_manage.js';
import { runCommit } from './commands/commit.js';
import { runMsg } from './commands/msg.js';
import { runHook } from './commands/hook.js';
import { runReport } from './commands/report.js';
import { runPr } from './commands/pr.js';
import { runRelease } from './commands/release.js';
import { runBranch } from './commands/branch.js';
import { checkUpdate } from './utils/update.js';
const require = createRequire(import.meta.url);
const pkg = require('../package.json');
const cli = cac('git-ai');
function shouldAllowUpdateCheck(argv) {
    const args = argv.slice(2);
    const hasFlag = (flag) => args.includes(flag) || args.some((arg) => arg.startsWith(`${flag}=`));
    // Avoid polluting machine-readable output or hooks.
    if (hasFlag('--json') || hasFlag('--quiet') || hasFlag('--hook'))
        return false;
    if (hasFlag('--help') || hasFlag('-h') || hasFlag('--version') || hasFlag('-v'))
        return false;
    // Avoid noisy output for message-only command.
    const cmd = args.find((arg) => !arg.startsWith('-'));
    if (cmd === 'msg')
        return false;
    return true;
}
// Default command (backward compatible) - interactive commit
cli
    .command('', 'Generate AI-powered commit message (interactive)')
    .option('-y, --yes', 'Skip confirmation and commit directly')
    .option('-n, --num <count>', 'Generate multiple commit messages to choose from', { default: 1 })
    .option('-l, --locale <locale>', 'Override locale (zh/en)')
    .option('-a, --agent', 'Use Agent mode for deep analysis and impact checking')
    .option('--hook', '[deprecated] Use `git-ai msg` instead')
    .action(async (options) => {
    try {
        // Deprecated --hook redirects to msg command behavior
        if (options.hook) {
            const { runMsg } = await import('./commands/msg.js');
            await runMsg({ quiet: true, locale: options.locale });
            return;
        }
        await runCommit({
            autoCommit: options.yes ?? false,
            numChoices: Math.min(Math.max(Number(options.num) || 1, 1), 5),
            locale: options.locale,
            agentMode: options.agent,
        });
    }
    catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        console.error(chalk.red(`\n❌ Error: ${message}\n`));
        process.exit(1);
    }
});
// Explicit commit subcommand
cli
    .command('commit', 'Generate and commit with AI message (interactive)')
    .option('-y, --yes', 'Skip confirmation and commit directly')
    .option('-n, --num <count>', 'Generate multiple commit messages to choose from', { default: 1 })
    .option('-l, --locale <locale>', 'Override locale (zh/en)')
    .option('-a, --agent', 'Use Agent mode for deep analysis and impact checking')
    .action(async (options) => {
    try {
        await runCommit({
            autoCommit: options.yes ?? false,
            numChoices: Math.min(Math.max(Number(options.num) || 1, 1), 5),
            locale: options.locale,
            agentMode: options.agent,
        });
    }
    catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        console.error(chalk.red(`\n❌ Error: ${message}\n`));
        process.exit(1);
    }
});
// Message-only command (for hooks and scripts)
cli
    .command('msg', 'Generate commit message only (stdout, for hooks/scripts)')
    .option('-n, --num <count>', 'Generate multiple messages', { default: 1 })
    .option('--json', 'Output as JSON')
    .option('--quiet', 'Suppress spinner and colors')
    .option('-l, --locale <locale>', 'Override locale (zh/en)')
    .action(async (options) => {
    try {
        await runMsg({
            num: Math.min(Math.max(Number(options.num) || 1, 1), 5),
            json: options.json ?? false,
            quiet: options.quiet ?? false,
            locale: options.locale,
        });
    }
    catch (error) {
        if (options.json) {
            console.log(JSON.stringify({ success: false, error: String(error) }));
        }
        else if (!options.quiet) {
            const message = error instanceof Error ? error.message : 'Unknown error';
            console.error(chalk.red(`\n❌ Error: ${message}\n`));
        }
        process.exit(1);
    }
});
cli
    .command('config [action] [key] [value]', 'Configure AI provider settings')
    .alias('init')
    .option('--json', 'Output as JSON (for get/set/describe)')
    .option('--local', 'Use local .git-ai.json (for get/set)')
    .action(async (action, key, value, options) => {
    try {
        const act = (action || '').trim();
        if (!act) {
            await runConfig();
            return;
        }
        if (act === 'get') {
            runConfigGet({ json: options?.json, local: options?.local });
            return;
        }
        if (act === 'describe') {
            runConfigDescribe({ json: options?.json });
            return;
        }
        if (act === 'set') {
            if (!key || value === undefined) {
                throw new Error('Usage: git-ai config set <key> <value>');
            }
            runConfigSet(key, value, { json: options?.json, local: options?.local });
            return;
        }
        throw new Error(`Unknown config action: ${act}`);
    }
    catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        console.error(chalk.red(`\n? Error: ${message}\n`));
        process.exit(1);
    }
});
cli
    .command('hook <action>', 'Manage Git hooks (install/remove/status)')
    .option('-g, --global', 'Apply to global Git hooks (all repositories)')
    .action(async (action, options) => {
    try {
        await runHook(action, { global: options.global });
    }
    catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        console.error(chalk.red(`\n❌ Error: ${message}\n`));
        process.exit(1);
    }
});
cli
    .command('report', 'Generate AI-powered weekly/daily reports from git history')
    .option('--days <number>', 'Number of days to analyze')
    .option('--from <date>', 'Start date (YYYY-MM-DD)')
    .option('--to <date>', 'End date (YYYY-MM-DD)')
    .option('--json', 'Output as JSON')
    .action(async (options) => {
    try {
        await runReport({
            days: options.days ? Number(options.days) : undefined,
            from: options.from,
            to: options.to,
            json: options.json,
        });
    }
    catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        console.error(chalk.red(`\n❌ Error: ${message}\n`));
        process.exit(1);
    }
});
cli
    .command('pr', 'Generate AI-powered pull request description')
    .option('--base <ref>', 'Base branch or ref (e.g., main)')
    .option('--head <ref>', 'Head ref (default: HEAD)')
    .option('--json', 'Output as JSON')
    .action(async (options) => {
    try {
        await runPr({
            base: options.base,
            head: options.head,
            json: options.json,
        });
    }
    catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        console.error(chalk.red(`\n❌ Error: ${message}\n`));
        process.exit(1);
    }
});
cli
    .command('release', 'Generate AI-powered release notes from git history')
    .option('--from <ref>', 'Start ref (default: last tag)')
    .option('--to <ref>', 'End ref (default: HEAD)')
    .option('--json', 'Output as JSON')
    .action(async (options) => {
    try {
        await runRelease({
            from: options.from,
            to: options.to,
            json: options.json,
        });
    }
    catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        console.error(chalk.red(`\n❌ Error: ${message}\n`));
        process.exit(1);
    }
});
cli
    .command('branch', 'Create a new branch with guided naming')
    .option('--type <type>', 'Branch type (feat/fix/docs/...)')
    .option('--name <name>', 'Branch name/slug')
    .option('--issue <id>', 'Issue ID (e.g., PROJ-123)')
    .option('--pattern <pattern>', 'Override branch pattern (e.g., {type}/{issue?}{name})')
    .option('--dry-run', 'Preview branch name without creating')
    .option('--json', 'Output as JSON')
    .action(async (options) => {
    try {
        await runBranch({
            type: options.type,
            name: options.name,
            issue: options.issue,
            pattern: options.pattern,
            dryRun: options.dryRun,
            json: options.json,
        });
    }
    catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        console.error(chalk.red(`\n❌ Error: ${message}\n`));
        process.exit(1);
    }
});
cli.help();
cli.version(pkg.version || '0.0.0');
const allowUpdateCheck = shouldAllowUpdateCheck(process.argv);
cli.parse();
// Check for updates asynchronously after command execution.
if (allowUpdateCheck) {
    let updateScheduled = false;
    process.on('beforeExit', () => {
        if (updateScheduled)
            return;
        updateScheduled = true;
        void checkUpdate({ allow: true });
    });
}
//# sourceMappingURL=cli_main.js.map